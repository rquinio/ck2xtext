/*
 * generated by Xtext 2.14.0
 */
package ck2xtext.common.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class Ck2TerminalsGrammarAccess extends AbstractGrammarElementFinder {
	
	public class DateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ck2xtext.common.Ck2Terminals.Date");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Keyword cFullStopKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final RuleCall cINTTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		///**
		// * See ck2xtext.conversion.DateValueConverter
		// */ Date ecore::EDate:
		//	INT '.' INT '.' INT;
		@Override public ParserRule getRule() { return rule; }
		
		//INT '.' INT '.' INT
		public Group getGroup() { return cGroup; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }
		
		//'.'
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_2() { return cINTTerminalRuleCall_2; }
		
		//'.'
		public Keyword getFullStopKeyword_3() { return cFullStopKeyword_3; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_4() { return cINTTerminalRuleCall_4; }
	}
	public class IntegerElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ck2xtext.common.Ck2Terminals.Integer");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cPlusSignKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//Integer ecore::EInt:
		//	('-' | '+')? INT;
		@Override public ParserRule getRule() { return rule; }
		
		//('-' | '+')? INT
		public Group getGroup() { return cGroup; }
		
		//('-' | '+')?
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_0_0() { return cHyphenMinusKeyword_0_0; }
		
		//'+'
		public Keyword getPlusSignKeyword_0_1() { return cPlusSignKeyword_0_1; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }
	}
	public class DoubleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ck2xtext.common.Ck2Terminals.Double");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIntegerParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Keyword cFKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		///**
		// * Note: Double do not match integers, for proper formatting
		// * 
		// * May end with 'f' in some cases
		// */ Double ecore::EDouble:
		//	Integer '.' INT 'f'?;
		@Override public ParserRule getRule() { return rule; }
		
		//Integer '.' INT 'f'?
		public Group getGroup() { return cGroup; }
		
		//Integer
		public RuleCall getIntegerParserRuleCall_0() { return cIntegerParserRuleCall_0; }
		
		//'.'
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_2() { return cINTTerminalRuleCall_2; }
		
		//'f'?
		public Keyword getFKeyword_3() { return cFKeyword_3; }
	}
	public class NumberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ck2xtext.common.Ck2Terminals.Number");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDoubleParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cIntegerParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Keyword cFKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		///*
		// * Used when decimals are not used systematically.
		// * 
		// * Warning: formatting might be messed up.
		// */ Number ecore::EDouble:
		//	Double | Integer 'f'?;
		@Override public ParserRule getRule() { return rule; }
		
		//Double | Integer 'f'?
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Double
		public RuleCall getDoubleParserRuleCall_0() { return cDoubleParserRuleCall_0; }
		
		//Integer 'f'?
		public Group getGroup_1() { return cGroup_1; }
		
		//Integer
		public RuleCall getIntegerParserRuleCall_1_0() { return cIntegerParserRuleCall_1_0; }
		
		//'f'?
		public Keyword getFKeyword_1_1() { return cFKeyword_1_1; }
	}
	
	
	private final TerminalRule tDIGIT;
	private final TerminalRule tBOOL;
	private final TerminalRule tHEX;
	private final TerminalRule tINT;
	private final TerminalRule tNON_ASCII_CAP;
	private final TerminalRule tNON_ASCII_LOW;
	private final TerminalRule tID_PART;
	private final TerminalRule tID;
	private final TerminalRule tSTRING;
	private final TerminalRule tSL_COMMENT;
	private final TerminalRule tWS;
	private final DateElements pDate;
	private final IntegerElements pInteger;
	private final DoubleElements pDouble;
	private final NumberElements pNumber;
	
	private final Grammar grammar;

	@Inject
	public Ck2TerminalsGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.tDIGIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ck2xtext.common.Ck2Terminals.DIGIT");
		this.tBOOL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ck2xtext.common.Ck2Terminals.BOOL");
		this.tHEX = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ck2xtext.common.Ck2Terminals.HEX");
		this.tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ck2xtext.common.Ck2Terminals.INT");
		this.tNON_ASCII_CAP = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ck2xtext.common.Ck2Terminals.NON_ASCII_CAP");
		this.tNON_ASCII_LOW = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ck2xtext.common.Ck2Terminals.NON_ASCII_LOW");
		this.tID_PART = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ck2xtext.common.Ck2Terminals.ID_PART");
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ck2xtext.common.Ck2Terminals.ID");
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ck2xtext.common.Ck2Terminals.STRING");
		this.tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ck2xtext.common.Ck2Terminals.SL_COMMENT");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ck2xtext.common.Ck2Terminals.WS");
		this.pDate = new DateElements();
		this.pInteger = new IntegerElements();
		this.pDouble = new DoubleElements();
		this.pNumber = new NumberElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("ck2xtext.common.Ck2Terminals".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	//terminal fragment DIGIT:
	//	'0'..'9';
	public TerminalRule getDIGITRule() {
		return tDIGIT;
	}
	
	//terminal BOOL returns ecore::EBoolean:
	//	'yes' | 'no';
	public TerminalRule getBOOLRule() {
		return tBOOL;
	}
	
	//terminal HEX returns ecore::EInt:
	//	'0x' (DIGIT | 'a' | 'b' | 'c' | 'd' | 'e' | 'f')+;
	public TerminalRule getHEXRule() {
		return tHEX;
	}
	
	//terminal INT returns ecore::EInt:
	//	DIGIT+;
	public TerminalRule getINTRule() {
		return tINT;
	}
	
	//terminal fragment NON_ASCII_CAP:
	//	'À' | 'Á' | 'Â' | 'Ã' | 'Ä' | 'Å' | 'Æ' | 'Ç' | 'È' | 'É' | 'Ê' | 'Ë' | 'Ì' | 'Í' | 'Î' | 'Ï' | 'Ð' | 'Ñ' | 'Ò' | 'Ó'
	//	| 'Ô' | 'Õ' | 'Ö' | 'Ø' | 'Š' | 'Ù' | 'Ú' | 'Û' | 'Ü' | 'Ý' | 'Ÿ' | 'Þ' | 'ß' | 'Œ';
	public TerminalRule getNON_ASCII_CAPRule() {
		return tNON_ASCII_CAP;
	}
	
	//terminal fragment NON_ASCII_LOW:
	//	'à' | 'á' | 'â' | 'ã' | 'ä' | 'å' | 'æ' | 'ç' | 'è' | 'é' | 'ê' | 'ë' | 'ì' | 'í' | 'î' | 'ï' | 'ð' | 'ñ' | 'ò' | 'ó'
	//	| 'ô' | 'õ' | 'ö' | 'ø' | 'š' | 'ù' | 'ú' | 'û' | 'ü' | 'ý' | 'ÿ' | 'ž' | 'þ' | 'œ';
	public TerminalRule getNON_ASCII_LOWRule() {
		return tNON_ASCII_LOW;
	}
	
	//terminal fragment ID_PART:
	//	'a'..'z' | 'A'..'Z' | NON_ASCII_LOW | NON_ASCII_CAP | '<';
	public TerminalRule getID_PARTRule() {
		return tID_PART;
	}
	
	//terminal ID:
	//	'^'? ID_PART (ID_PART | DIGIT | '_' | '-' | '\'' | '’' | ':' | '.' | '>' | '@')*;
	public TerminalRule getIDRule() {
		return tID;
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"';
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	}
	
	//terminal SL_COMMENT:
	//	'#' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return tSL_COMMENT;
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return tWS;
	}
	
	///**
	// * See ck2xtext.conversion.DateValueConverter
	// */ Date ecore::EDate:
	//	INT '.' INT '.' INT;
	public DateElements getDateAccess() {
		return pDate;
	}
	
	public ParserRule getDateRule() {
		return getDateAccess().getRule();
	}
	
	//Integer ecore::EInt:
	//	('-' | '+')? INT;
	public IntegerElements getIntegerAccess() {
		return pInteger;
	}
	
	public ParserRule getIntegerRule() {
		return getIntegerAccess().getRule();
	}
	
	///**
	// * Note: Double do not match integers, for proper formatting
	// * 
	// * May end with 'f' in some cases
	// */ Double ecore::EDouble:
	//	Integer '.' INT 'f'?;
	public DoubleElements getDoubleAccess() {
		return pDouble;
	}
	
	public ParserRule getDoubleRule() {
		return getDoubleAccess().getRule();
	}
	
	///*
	// * Used when decimals are not used systematically.
	// * 
	// * Warning: formatting might be messed up.
	// */ Number ecore::EDouble:
	//	Double | Integer 'f'?;
	public NumberElements getNumberAccess() {
		return pNumber;
	}
	
	public ParserRule getNumberRule() {
		return getNumberAccess().getRule();
	}
}
